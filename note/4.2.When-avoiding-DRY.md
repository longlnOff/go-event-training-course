# When to Avoid DRY (Don't Repeat Yourself)

## The Problem: Ad-hoc Solutions

Susan noticed code that modified data structures in-place within HTTP handlers:

```go
user, err := h.db.GetUser(r.Context(), authUser.UUID)
if err != nil {
    httperr.InternalError("cannot-get-user", err, w, r)
    return
}
user.Role = authUser.Role
user.DisplayName = authUser.DisplayName

render.Respond(w, r, user)
```

**Issue**: The HTTP handler was modifying the user object directly, coupling the REST API layer with the database layer.

## The Refactoring Solution

Susan proposed separating concerns by creating distinct structures:

### Before (Coupled)

- Single `User` struct shared between database and HTTP layers
- Direct modification of database model for API responses

### After (Decoupled)

**Database Model** (`internal/users/firestore.go`):

```go
type UserModel struct {
    Balance     int
    DisplayName string
    Role        string
    LastIP      string
}
```

**HTTP Handler** (`internal/users/http.go`):
```go
userResponse := User{
    DisplayName: authUser.DisplayName,
    Balance:     user.Balance,
    Role:        authUser.Role,
}

render.Respond(w, r, userResponse)
```

## The Clash of Principles

**Dave's Concern**:
- The refactored solution breaks the DRY principle
- Introduces boilerplate code

**Susan's Concern**:
- The original approach violates the Single Responsibility Principle (SRP - the "S" in SOLID)
- Ad-hoc solutions can quickly get out of control

## Key Takeaways

### When to Avoid DRY

1. **Ask the Right Question**: Will the code using the common structure likely change together?
   - If **NO**  Duplication is the right choice
   - If **YES**  DRY might be appropriate

2. **Code Coupling vs. Duplication**: Sometimes code duplication is one of the best tools to fight code coupling

3. **Apply DRY to Behaviors, Not Data**:
   - DRY is usually better applied to behaviors (e.g., extracting common code to functions)
   - Data structures can be duplicated to maintain separation of concerns
   - Extracting common behavior to functions doesn't have the same coupling downsides

## Example: DRY Applied to Behaviors

### Before (Repeated Behavior)

```go
// In user handler
func (h *HttpServer) GetUser(w http.ResponseWriter, r *http.Request) {
    authUser, err := auth.UserFromCtx(r.Context())
    if err != nil {
        httperr.Unauthorised("no-user-in-context", err, w, r)
        return
    }
    if authUser.Role != "admin" {
        httperr.Unauthorised("invalid-role", nil, w, r)
        return
    }

    // ... handler logic
}

// In trainer handler
func (h *HttpServer) CreateTraining(w http.ResponseWriter, r *http.Request) {
    authUser, err := auth.UserFromCtx(r.Context())
    if err != nil {
        httperr.Unauthorised("no-user-in-context", err, w, r)
        return
    }
    if authUser.Role != "admin" {
        httperr.Unauthorised("invalid-role", nil, w, r)
        return
    }

    // ... handler logic
}

// In hours handler
func (h *HttpServer) UpdateHours(w http.ResponseWriter, r *http.Request) {
    authUser, err := auth.UserFromCtx(r.Context())
    if err != nil {
        httperr.Unauthorised("no-user-in-context", err, w, r)
        return
    }
    if authUser.Role != "admin" {
        httperr.Unauthorised("invalid-role", nil, w, r)
        return
    }

    // ... handler logic
}
```

**Problem**: The same authorization logic is repeated in multiple handlers.

### After (DRY Applied to Behavior)

```go
// Extract common behavior into middleware
func (h *HttpServer) AdminOnly(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authUser, err := auth.UserFromCtx(r.Context())
        if err != nil {
            httperr.Unauthorised("no-user-in-context", err, w, r)
            return
        }
        if authUser.Role != "admin" {
            httperr.Unauthorised("invalid-role", nil, w, r)
            return
        }

        next.ServeHTTP(w, r)
    })
}

// Handlers become cleaner
func (h *HttpServer) GetUser(w http.ResponseWriter, r *http.Request) {
    // ... handler logic only
}

func (h *HttpServer) CreateTraining(w http.ResponseWriter, r *http.Request) {
    // ... handler logic only
}

func (h *HttpServer) UpdateHours(w http.ResponseWriter, r *http.Request) {
    // ... handler logic only
}

// Router setup
router.Handle("/users/{id}", h.AdminOnly(http.HandlerFunc(h.GetUser))).Methods("GET")
router.Handle("/trainings", h.AdminOnly(http.HandlerFunc(h.CreateTraining))).Methods("POST")
router.Handle("/hours", h.AdminOnly(http.HandlerFunc(h.UpdateHours))).Methods("PUT")
```

### Another Example: Error Handling Pattern

**Before (Repeated Behavior)**:

```go
func (h *HttpServer) GetTraining(w http.ResponseWriter, r *http.Request) {
    trainingID := chi.URLParam(r, "trainingID")

    training, err := h.db.GetTraining(r.Context(), trainingID)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            httperr.NotFound("training-not-found", err, w, r)
            return
        }
        httperr.InternalError("cannot-get-training", err, w, r)
        return
    }

    render.Respond(w, r, training)
}

func (h *HttpServer) GetUser(w http.ResponseWriter, r *http.Request) {
    userID := chi.URLParam(r, "userID")

    user, err := h.db.GetUser(r.Context(), userID)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            httperr.NotFound("user-not-found", err, w, r)
            return
        }
        httperr.InternalError("cannot-get-user", err, w, r)
        return
    }

    render.Respond(w, r, user)
}
```

**After (DRY Applied to Behavior)**:

```go
// Extract common error handling pattern
func handleDatabaseError(err error, resourceName string, w http.ResponseWriter, r *http.Request) bool {
    if err == nil {
        return false
    }

    if errors.Is(err, sql.ErrNoRows) {
        httperr.NotFound(resourceName+"-not-found", err, w, r)
        return true
    }

    httperr.InternalError("cannot-get-"+resourceName, err, w, r)
    return true
}

func (h *HttpServer) GetTraining(w http.ResponseWriter, r *http.Request) {
    trainingID := chi.URLParam(r, "trainingID")
    training, err := h.db.GetTraining(r.Context(), trainingID)

    if handleDatabaseError(err, "training", w, r) {
        return
    }

    render.Respond(w, r, training)
}

func (h *HttpServer) GetUser(w http.ResponseWriter, r *http.Request) {
    userID := chi.URLParam(r, "userID")
    user, err := h.db.GetUser(r.Context(), userID)

    if handleDatabaseError(err, "user", w, r) {
        return
    }

    render.Respond(w, r, user)
}
```

### Key Difference

**DRY for Behaviors (Good)**:
- Extracts repeated logic/algorithms
- Changes to the behavior affect all usages equally
- Example: Middleware, utility functions, error handling patterns

**DRY for Data (Often Bad)**:
- Forces different concerns to share the same structure
- Changes in one area affect unrelated areas
- Example: Sharing User struct between database, API, and domain layers

### Benefits of the Refactored Approach

- **Separation of Concerns**: Database layer and REST API layer are decoupled
- **Easier to Maintain**: Changes to API structure don't affect database model and vice versa
- **Clearer Intent**: Each structure has a specific purpose
- **Future-proof**: Adding fields to one layer doesn't impact the other

## Summary

There are no strict rules, but it's important to balance principles:
- DRY helps reduce redundancy
- But premature abstraction can introduce harmful coupling
- Sometimes "boilerplate" is actually valuable separation of concerns
- Consider the likelihood of independent changes when deciding whether to share structures
